global string $nifToolsMenu;
global string $nifToolsStackHeapArray[];

global proc nifTranslatorMenuCreate() {
	global string $nifToolsMenu;
	global string $gMainWindow;
    setParent $gMainWindow;

    $nifToolsMenu = `menu -label "NifTools" -allowOptionBoxes false -tearOff true`;

		menuItem -label "Animation" -subMenu true animationMenu;

			menuItem -label "Rotation type" -subMenu true;
				menuItem -label "Set rotation type to XYZ" -command "nifTranslatorSetXYZRotation";
				menuItem -label "Set rotation type to quaternion" -command "nifTranslatorSetQuaternionRotation";
			setParent -menu animationMenu;

			menuItem -label "Exporting indexes" -subMenu true;
				menuItem -label "Set default export index" -command "nifTranslatorSetDefaultExportIndex";
				menuItem -label "Set export indexes to DFS" -command "nifTranslatorSetExportIndexesToDFS";
				menuItem -label "Set export indexes to BFS" -command "nifTranslatorSetExportIndexesToBFS";
			setParent -menu animationMenu;

			menuItem -label "Interpolator type" -subMenu true;
				menuItem -label "Set to NiTransformInterpolator" -command "nifTranslatorSetInterpolatorToNiTransformInterpolator";
				menuItem -label "Set to NiBSplineTransformInterpolator" -command "nifTranslatorSetInterpolatorToNiBSplineInterpolator";
				menuItem -label "Set to NiBSplineCompTransformInterpolator" -command "nifTranslatorSetInterpolatorToNiBSplineCompInterpolator";
				menuItem -label "Set to NiPoint3Interpolator" -command "nifTranslatorSetInterpolatorToNiPoint3Interpolator";
			setParent -menu animationMenu;

			menuItem -label "Rest transformation" -subMenu true;
				menuItem -label "Set rest translate" -command "nifTranslatorSetTranslateRest2";
				menuItem -label "Set rest scale" -command "nifTranslatorSetScaleRest2";
				menuItem -label "Set rest rotate" -command "nifTranslatorSetRotateRest2";
			setParent -menu animationMenu;

			menuItem -label "Others" -subMenu true;
				menuItem -label "Set animation priority" -command "nifTranslatorSetAnimationPriority";
				menuItem -label "Prepare skeleton for animation" -command "nifTranslatorPrepareSkeletonForAnimation";
			setParent -menu animationMenu;

		setParent -menu $nifToolsMenu;

		menuItem -label "Texture" -subMenu true textureMenu;
			menuItem -label "Set texturing mode to Apply Modular";
			menuItem -label "Set texturing mode to Apply Highlight";
			menuItem -label "Set texturing mode to Apply Highlight2";
		setParent -menu $nifToolsMenu;

	setParent $gMainWindow;
}

global proc nifTranslatorSetTranslateRest2() {
	string $selection[] = `ls -selection -type "joint" -type "shape"`;

	for($i = 0; $i < size($selection); $i++) {
		nifTranslatorSetTranslateRest($selection[$i]);
	}
}

global proc nifTranslatorSetScaleRest2() {
	string $selection[] = `ls -selection -type "joint" -type "shape"`;

	for($i = 0; $i < size($selection); $i++) {
		nifTranslatorSetScaleRest($selection[$i]);
	}
}

global proc nifTranslatorSetRotateRest2() {
	string $selection[] = `ls -selection -type "joint" -type "shape"`;

	for($i = 0; $i < size($selection); $i++) {
		nifTranslatorSetRotateRest($selection[$i]);
	}
}

global proc nifTranslatorPrepareSkeletonForAnimation() {
	int $index = 0;
	string $parent[];
	string $selection[] = `ls -selection -type "joint"`;

	if(size($selection) < 1 || size($selection) > 1) {
		error "Must select one joint from the skeleton first";
		return;
	}

	while(size($selection) > 0) {
		$parent = $selection;
		$selection = `listRelatives -parent $parent[0]`;
	}

	nifToolsStackClear();
	nifToolsStackPush($parent[0]);

	while(nifToolsStackSize() > 0) {
		string $current = nifToolsStackPop();
		string $attributes[] = eval("listAttr -shortNames " + $current);

		int $hasRotationType = 0;
		int $hasInterpolatorType = 0;
		int $hasAnimationPriority = 0;

		for($i = 0; $i < size($attributes); $i++) {
			if($attributes[$i] == "rotationType") {
				$hasRotationType = 1;
				continue;
			}
			if($attributes[$i] == "interpolatorType") {
				$hasInterpolatorType = 1;
				continue;
			}
			if($attributes[$i] == "animationPriority") {
				$hasAnimationPriority = 1;
				continue;
			}
		}

		nifTranslatorSetTranslateRest($current);
		nifTranslatorSetScaleRest($current);
		nifTranslatorSetRotateRest($current);

		if($hasInterpolatorType == 0) { 
			eval("addAttr -dataType \"string\" -shortName \"interpolatorType\" " + $current);	
		}
		eval("setAttr -type \"string\" " + $current + "\.interpolatorType" + " \"NiTransformInterpolator\" ");

		if($hasRotationType == 0) {
			eval("addAttr -dataType \"string\" -shortName \"rotationType\" " + $current);	
		}
		eval("setAttr -type \"string\" " + $current + "\.rotationType" + " " + " \"XYZ\" ");

		if($hasAnimationPriority == 0) { 
			eval("addAttr -at byte -shortName \"animationPriority\" " + $current);
		}
		eval("setAttr " + $current + "\.animationPriority" + " " + 30);

		nifTranslatorSetExportIndex($current, $index);

		string $children[] = `listRelatives -children -type "joint" $current`;
		$index++;

		for($i = 0; $i < size($children); $i++) {
			nifToolsStackPush($children[$i]);
		}
	}
}

global proc nifTranslatorSetTranslateRest(string $item) {
	string $attributes[] = `listAttr -shortNames $item`;

	int $hasAttr = 0;

	float $restX = eval("getAttr " + $item + "\.translateX");
	float $restY = eval("getAttr " + $item + "\.translateY");
	float $restZ = eval("getAttr " + $item + "\.translateZ");

	for($i = 0; $i < size($attributes); $i++) {
		if($attributes[$i] == "translateRest") {
			$hasAttr = 1;
			break;
		}
	}

	if($hasAttr == 0) {
		eval("addAttr -shortName \"translateRest\" -attributeType double3 " + $item);
		eval("addAttr -shortName \"translateRestX\" -attributeType double -parent \"translateRest\" " + $item);
		eval("addAttr -shortName \"translateRestY\" -attributeType double -parent \"translateRest\" " + $item);
		eval("addAttr -shortName \"translateRestZ\" -attributeType double -parent \"translateRest\" " + $item);
	}

	eval("setAttr " + $item + "\.translateRestX " + $restX);
	eval("setAttr " + $item + "\.translateRestY " + $restY);
	eval("setAttr " + $item + "\.translateRestZ " + $restZ);
}

global proc nifTranslatorSetScaleRest(string $item) {
	string $attributes[] = `listAttr -shortNames $item`;

	int $hasAttr = 0;

	float $restX = eval("getAttr " + $item + "\.scaleX");
	float $restY = eval("getAttr " + $item + "\.scaleY");
	float $restZ = eval("getAttr " + $item + "\.scaleZ");

	for($i = 0; $i < size($attributes); $i++) {
		if($attributes[$i] == "scaleRest") {
			$hasAttr = 1;
			break;
		}
	}

	if($hasAttr == 0) {
		eval("addAttr -shortName \"scaleRest\" -attributeType double3 " + $item);
		eval("addAttr -shortName \"scaleRestX\" -attributeType double -parent \"scaleRest\" " + $item);
		eval("addAttr -shortName \"scaleRestY\" -attributeType double -parent \"scaleRest\" " + $item);
		eval("addAttr -shortName \"scaleRestZ\" -attributeType double -parent \"scaleRest\" " + $item);
	}

	eval("setAttr " + $item + "\.scaleRestX " + $restX);
	eval("setAttr " + $item + "\.scaleRestY " + $restY);
	eval("setAttr " + $item + "\.scaleRestZ " + $restZ);
}

global proc nifTranslatorSetRotateRest(string $item) {
	string $attributes[] = `listAttr -shortNames $item`;

	int $hasAttr = 0;

	float $restX = eval("getAttr " + $item + "\.rotateX");
	float $restY = eval("getAttr " + $item + "\.rotateY");
	float $restZ = eval("getAttr " + $item + "\.rotateZ");

	for($i = 0; $i < size($attributes); $i++) {
		if($attributes[$i] == "rotateRest") {
			$hasAttr = 1;
			break;
		}
	}

	if($hasAttr == 0) {
		eval("addAttr -shortName \"rotateRest\" -attributeType double3 " + $item);
		eval("addAttr -shortName \"rotateRestX\" -attributeType double -parent \"rotateRest\" " + $item);
		eval("addAttr -shortName \"rotateRestY\" -attributeType double -parent \"rotateRest\" " + $item);
		eval("addAttr -shortName \"rotateRestZ\" -attributeType double -parent \"rotateRest\" " + $item);
	}

	eval("setAttr " + $item + "\.rotateRestX " + $restX);
	eval("setAttr " + $item + "\.rotateRestY " + $restY);
	eval("setAttr " + $item + "\.rotateRestZ " + $restZ);
}

global proc nifTranslatorSetXYZRotation() {
	nifTranslatorSetRotationType("XYZ");
}

global proc nifTranslatorSetQuaternionRotation() {
	nifTranslatorSetRotationType("quaternion");
}

global proc nifTranslatorSetRotationType(string $type) {
	string $selection[] = `ls -selection -type "joint" -type "shape"`;

	for($i = 0;$i < size($selection); $i++) {
		int $hasAttr = 0;
		string $attributes[] = `listAttr -shortNames $selection[$i]`;

		for($j = 0;$j < size($attributes); $j++) {
			if($attributes[$j] == "rotationType") {
				$hasAttr = 1;
				break; 
			}
		}

		if($hasAttr == 0) { 
			eval("addAttr -dataType \"string\" -shortName \"rotationType\" " + $selection[$i]);	
		}
		eval("setAttr -type \"string\" " + $selection[$i] + "\.rotationType" + " " + $type);
	}

	if(size($selection) == 0) {
		error "Must select at least one joint or shape";
	}
}

global proc nifTranslatorSetInterpolatorToNiTransformInterpolator() {
	nifTranslatorSetInterpolator("NiTransformInterpolator");
}

global proc nifTranslatorSetInterpolatorToNiBSplineCompInterpolator() {
	nifTranslatorSetInterpolator("NiBSplineCompTransformInterpolator");
}

global proc nifTranslatorSetInterpolatorToNiPoint3Interpolator() {
	nifTranslatorSetInterpolator("NiPoint3Interpolator");
}

global proc nifTranslatorSetInterpolatorToNiBSplineInterpolator() {
	nifTranslatorSetInterpolator("NiBSplineTransformInterpolator");
}

global proc nifTranslatorSetInterpolator(string $type) {
	string $selection[] = `ls -selection -type "joint" -type "shape"`;

	for($i = 0;$i < size($selection); $i++) {
		int $hasAttr = 0;
		string $attributes[] = `listAttr -shortNames $selection[$i]`;

		for($j = 0;$j < size($attributes); $j++) {
			if($attributes[$j] == "interpolatorType") {
				$hasAttr = 1;
				break; 
			}
		}

		if($hasAttr == 0) { 
			eval("addAttr -dataType \"string\" -shortName \"interpolatorType\" " + $selection[$i]);	
		}
		eval("setAttr -type \"string\" " + $selection[$i] + "\.interpolatorType" + " " + $type);
	}

	if(size($selection) == 0) {
		error "Must select at least one joint or shape";
	}
}

global proc nifTranslatorSetAnimationPriority() {
	string $selection[] = `ls -selection -type "joint" -type "shape"`;

	for($i = 0;$i < size($selection); $i++) {
		int $hasAttr = 0;
		string $attributes[] = `listAttr -shortNames $selection[$i]`;

		for($j = 0;$j < size($attributes); $j++) {
			if($attributes[$j] == "animationPriority") {
				$hasAttr = 1;
				break; 
			}
		}

		if($hasAttr == 0) { 
			eval("addAttr -at byte -shortName \"animationPriority\" " + $selection[$i]);
		}
		eval("setAttr " + $selection[$i] + "\.animationPriority" + " " + 30);
	}

	if(size($selection) == 0) {
		error "Must select at least one joint or shape";
	}
}

global proc nifTranslatorSetDefaultExportIndex() {
	string $selection[] = `ls -selection -type "joint" -type "shape"`;

	for($i = 0;$i < size($selection); $i++) {
		nifTranslatorSetExportIndex($selection[$i], 0);
	}

	if(size($selection) == 0) {
		error "Must select at least one joint or shape";
	}
}

global proc nifTranslatorSetExportIndex(string $object, int $value) {
	int $hasAttr = 0;
	string $attributes[] = `listAttr -shortNames $object`;

	for($j = 0;$j < size($attributes); $j++) {
		if($attributes[$j] == "exportIndex") {
			$hasAttr = 1;
			break; 
		}
	}

	if($hasAttr == 0) { 
		eval("addAttr -at long -shortName \"exportIndex\" " + $object);
	}
	eval("setAttr " + $object + "\.exportIndex" + " " + $value);
}

global proc nifTranslatorSetExportIndexesToDFS() {
	int $index = 0;
	string $parent[];
	string $selection[] = `ls -selection -type "joint"`;

	if(size($selection) < 1 || size($selection) > 1) {
		error "Must select one joint from the skeleton first";
		return;
	}

	while(size($selection) > 0) {
		$parent = $selection;
		$selection = `listRelatives -parent $parent[0]`;
	}

	nifToolsStackClear();
	nifToolsStackPush($parent[0]);

	while(nifToolsStackSize() > 0) {
		string $current = nifToolsStackPop();
		nifTranslatorSetExportIndex($current, $index);
		string $children[] = `listRelatives -children -type "joint" $current`;
		$index++;

		for($i = 0; $i < size($children); $i++) {
			nifToolsStackPush($children[$i]);
		}
	}
}

global proc nifTranslatorSetExportIndexesToBFS() {
	int $index = 0;
	string $parent[];
	string $selection[] = `ls -selection -type "joint"`;

	if(size($selection) < 1 || size($selection) > 1) {
		error "Must select one joint from the skeleton first";
		return;
	}

	while(size($selection) > 0) {
		$parent = $selection;
		$selection = `listRelatives -parent $parent[0]`;
	}

	nifToolsQueueClear();
	nifToolsQueueEnqueue($parent[0]);

	while(nifToolsQueueSize() > 0) {
		string $current = nifToolsQueueDequeue();
		nifTranslatorSetExportIndex($current, $index);
		string $children[] = `listRelatives -children -type "joint" $current`;
		$index++;

		for($i = 0; $i < size($children); $i++) {
			nifToolsQueueEnqueue($children[$i]);
		}
	}
}

global proc string nifToolsStackPop() {
	global string $nifToolsStackHeapArray[];

	if(size($nifToolsStackHeapArray) == 0) {
		return "";
	}

	string $ret = $nifToolsStackHeapArray[size($nifToolsStackHeapArray) - 1];

	string $newArray[];

	for($i = 0; $i < size($nifToolsStackHeapArray) - 1; $i++) {
		$newArray[$i] = $nifToolsStackHeapArray[$i];
	}

	$nifToolsStackHeapArray = $newArray;

	return $ret;
}

global proc nifToolsStackPush(string $item) {
	global string $nifToolsStackHeapArray[];

	$nifToolsStackHeapArray[size($nifToolsStackHeapArray)] = $item;
}

global proc nifToolsStackClear() {
	global string $nifToolsStackHeapArray[];

	clear($nifToolsStackHeapArray);
}

global proc int nifToolsStackSize() {
	global string $nifToolsStackHeapArray[];

	return size($nifToolsStackHeapArray);
}

global proc nifToolsQueueEnqueue(string $item) {
	global string $nifToolsStackHeapArray[];

	$nifToolsStackHeapArray[size($nifToolsStackHeapArray)] = $item;
}

global proc string nifToolsQueueDequeue() {
	global string $nifToolsStackHeapArray[];

	if(size($nifToolsStackHeapArray) == 0) {
		return "";
	}

	string $ret = $nifToolsStackHeapArray[0];

	string $newArray[];

	for($i = 1; $i < size($nifToolsStackHeapArray); $i++) {
		$newArray[$i - 1] = $nifToolsStackHeapArray[$i];
	}

	$nifToolsStackHeapArray = $newArray;

	return $ret;
}

global proc int nifToolsQueueSize() {
	global string $nifToolsStackHeapArray[];

	return size($nifToolsStackHeapArray);
}

global proc nifToolsQueueClear() {
	global string $nifToolsStackHeapArray[];

	clear($nifToolsStackHeapArray);
}